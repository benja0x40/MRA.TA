% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/segmentation.R
\name{segmentation}
\alias{segmentation}
\title{Multi-resolution segmentation}
\usage{
segmentation(Yi, name, wmax = 0, wmin = 3, gamma = 1, Tw = 0)
}
\arguments{
\item{Yi}{vector of statistical scores produced by the \link{enrichmentScore} function.}

\item{name}{prefix used to generate output file names.}

\item{wmax}{maximal window size to be scanned in number of Yi values.
The default is \code{length(Yi)}.}

\item{wmin}{minimum size of segmented domains in number of Yi values.
The default is 3 consecutive Yi values.}

\item{gamma}{stringency factor ranging from ]0;1].
Default value is 1.0 and lower values correspond to increased stringency.}

\item{Tw}{log value ranging from ]\code{-Inf};0] and indicating the minimal statistical
scores (e.g. pseudo p-values from combined rank-based scores) accepted for
segmented domains.
Default value is 0 and equivalent to an absence of cutoff while lower values
correspond to more stringent cutoffs.}
}
\value{
\code{segmentation} returns a list object with the following attributes:
\item{time.optimization}{computation time for the optimization procedure}
\item{time.MRT.Analysis}{computation time for the domain fusion procedure}
\item{n.segments}{total number of locally optimal segments after optimization}
\item{n.domains}{total number of domains after domain fusion}
\item{n.maxresolution}{number of maximum resolution domains}
\item{n.maxscale}{number of maximum scale domains}
\item{file.segments}{result file for the optimization procedure}
\item{file.domains}{result file for the domain fusion procedure}
\item{file.maxresolution}{result file for maximum resolution domains}
\item{file.maxscale}{result file for maximum scale domains}
\item{Pw.min}{best statistical score (pseudo p-values from combined rank-based scores) for each scanned window size}
}
\description{

}
\section{Output files}{
 \itemize{
\item Common structure

All output files are tab delimited text files including two header lines.
\preformatted{ line 1 = analysis parameters line 2 = column names following
lines = data table }

\item \code{file.segments}

This file contains the optimal segment data, resulting from the the
optimization procedure, and defined by columns (i, w, Piw) as follows:
\preformatted{ i = index of the last Yi value within the optimal segment w =
size in number of consecutive Yi values Piw = statistical score }

\item \code{file.domains}, \code{file.maxresolution}, \code{file.maxscale}

These files contain the segmented domain data, resulting from the domain
fusion procedure, and defined by columns (id, container, start, end, wmin,
wmax, P, i, w) as follows: \preformatted{ id = unique identifier for each
domain container = identifier of parent domain, 0 meaning no parent start =
index of the first Yi value within domain end = index of the last Yi value
within domain wmin = minimum size of included optimal segments, in number of
Yi values wmax = maximum size of included optimal segments, in number of Yi
values P = statistical score of the locally optimal segment i = index of the
last Yi value within the locally optimal segment w = size of the locally
optimal segment in number of consecutive Yi values }
}
}
\examples{
# Simulate enrichment signal
n <- 2000
Mi <- rep(0, n)
Mi <- Mi + dnorm(1:n, 2.5*n/20,  n/40) + dnorm(1:n, 4*n/20,  50)
Mi <- Mi + 4 * dnorm(1:n, 5*n/10, n/10)
Mi <- Mi + dnorm(1:n, 16*n/20,  n/40) + dnorm(1:n, 17.5*n/20,  50)
Mi <- (Mi/max(Mi))^4 + rnorm(n)/4

# Compute enrichment scores
Yi <- enrichmentScore(Mi)

# Multi-resolution segmentation
seg.c <- segmentation(Yi, name="MRA_demo", wmin=20)

# Load segmentation results
opts <- read.delim(seg.c$file.segments, stringsAsFactors=F, skip=1)
doms <- read.delim(seg.c$file.domains, stringsAsFactors=F)
doms.mr <- read.delim(seg.c$file.maxresolution, stringsAsFactors=F)
doms.ms <- read.delim(seg.c$file.maxscale, stringsAsFactors=F)

# Visualization coordinates
x.s <- 1:n - 0.5
x.e <- 1:n + 0.5
w2y <- wSize2yAxis(n, logscale=T)

layout(matrix(1:2, 2, 1), heights=c(3,1)/4)
par(mar=c(3, 4, 1, 2)) # default bottom, left, top, right = c(5, 4, 4, 2)

# Plot domainogram
domainogram(Yi, x.s, x.e, w2y)
plot(Mi, type='l', xaxs = 'i')

# Visualize segmentation results
plotOptimalSegments(opts, x.s, x.e, w2y, col="black")
plot(Mi, type='l', xaxs = 'i')

# Visualize multi-resolution domains
plotDomains(doms, x.s, x.e, w2y, col=rgb(0,0,0,0.5), border=rgb(0,0,0,0))
# Visualize max. resolution and max. scale domains
plotDomains(doms.mr, x.s, x.e, w2y, col=rgb(0,1,0,0.5), border=rgb(0,0,0,0), lwd=2, lty=1, add=T)
plotDomains(doms.ms, x.s, x.e, w2y, col=rgb(1,0,0,0.5), border=rgb(0,0,0,0), lwd=2, lty=1, add=T)
legend("topright", c("Max. resolution", "Max. scale", "Both"), fill=c("green", "red", "chocolate"), bty='n')
plot(Mi, type='l', xaxs = 'i')
}
\author{
Benjamin Leblanc
}
\seealso{
\link{calc.Qi},
   \link{enrichmentScore},
   \link{domainogram},
   \link{plotOptimalSegments},
   \link{plotDomains}
}

